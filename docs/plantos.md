# ttweb on PlantOS

提示：本项目正在快速开发中，所以本文档暂且以杂文的形式呈现。

我在 2023 年圣诞节为 ttweb2 定下了三大核心目标：更健壮和优美，更实用和方便，以及更低的性能要求。
即便为了快速开发，ttweb2 实际上没有计划中那样优美的代码，没有计划中那样实用的文档，但更低的性能要求是完全做到了。
在 Linux 都要准备放弃 32位 X86 处理器的今天，十五年前的设备已经几乎无法使用了，而时代的发展只会越来越快，而那些设备最终要变成电子垃圾。
在 2024 年元旦，我决定要做些有趣的事情，我要用三张软盘装下 ttweb2 。

正好，一张软盘便可以装下 PlantOS ，它是我的一位朋友开发的。事实上，标准的 PlantOS 构建包含了 Lua 、 JavaScript 、专门为该操作系统设计的配置文件格式。但这些在极端情况下都是不必要的，并且，在 PlantOS 中编写复杂 Lua 脚本实际上是一件十分折磨的事情——没有文档，没有语法高亮，没有错误检查。我小时候使用过 Emacs 和 TeX，在此之后我十分喜欢这种设计出一门编程语言用以高层的项目开发的模式。再后来我接触了 Chez Scheme 、 SBCL 、一些理论计算机科学，这让我更加坚定这种想法的同时让我选择了 Lisp 作为二次开发的语言。当然，我当时对 Lisp 是一知半解的，完全没有考虑过 call/cc 和 shift/reset 之类对 Lisp 的助力，但反而，Ghost Lisp 简单的内核让它的代码比 Scheme 更容易被理解——完全可以把 Ghost Lisp 当作 Ghost Code 的延伸，我在设计 Ghost Lisp 时就是以扩展 Ghost Code 为目标的。我当时从未考虑过用 Ghost Lisp 做一些 hack 的事情——比如用它来写 Markdown 编译器。但逐渐的，由于我个人博客的短暂设立，我真的需要一个 Markdown 编译器和图床——那么就用 Ghost Lisp 写一个吧。这又暗合了我最初的想法，从最简单的功能开始逐步的学习 ttweb ，但它灵活到能做一些我们难以想象的事情——实际上，当前版本的 ttweb 做的还不够，还有很多扩展它的计划。

所以，我最终从头实现了一切，这并不是在标新立异，也不是对几个部分的简单捆绑，相反，ttweb 核心与 glisp 是一个难以分割的整体（虽然你其实可以只编译核心，如果你实在想用其它脚本语言，例如 psh (PlantOS Shell) 的 Lua 或者更常见且通用的 Python）。

我们通过转译层来伪装 PlantOS 为 Linux（默认）或其它操作系统（目前的转译层仅针对 Linux 开发）。
对 Linux 的 系统调用 (syscall) 会被转译成对 PlantOS 的 系统调用。
我们编写的程序会被编译为一个包含 stdlib 的静态链接库，它会和 libc（官方 libc 的 PlantOS 分支） 库，系统库，转译层库一起被链接成最终的程序。
它尽可能多的剔除了无用调用，并且 stdlib 是动态编译的，所以并不需要转译所有系统调用就可以正常编写或移植程序。

经过一番操作，Hello World 程序可以被压缩到 70kb 以下。

所以，我曾经称 PRTL (PlantOS Rust Translation Layer，PlantOS Rust 转译层) 为“飞线”或“插线板”。但无论如何，仅仅是通过这些“飞线”代码，一个现代的、功能完备的 webserver 可以被编译到了一个本体不到 1MB 的操作系统上。HTTPS 相关代码已经写了大部分，我已经实现了 X25519 和 secp256r1 算法，这将最新的标准引入了 ttweb ，而我们的项目仍然保持一贯的极其简洁的零依赖——事实上，这是一个很大的挑战，大多数 webserver 都使用了各种庞大的依赖软件，或者根本不实现 HTTPS ，让 Nginx 来实现这一部分——但我们不可能在这么局促的硬盘空间内使用这种方法，复杂的依赖也不符合我“让用户明白自己的电脑里在跑着什么东西”的理念。

无论如何，ttweb on PlantOS 暂且还是一个理想——诚然 PRTL 已经可以用于正常编写程序，但对于充分利用标准库的 ttweb ，仍然需要一段时间才能将其移植。